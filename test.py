from attack.PGD import PGD
from attack.FGSM import FGSM
import os
import torch
from scipy.io.wavfile import write
import numpy as np
from speechbrain.pretrained import EncoderDecoderASR

bits = 16
def parse_args():
    import argparse

    parser = argparse.ArgumentParser()

    subparser = parser.add_subparsers(dest='system_type') # either iv (ivector-PLDA) or xv (xvector-PLDA)

    iv_parser = subparser.add_parser("iv_plda")
    iv_parser.add_argument('-gmm', default='pre-trained-models/iv_plda/final_ubm.txt')
    iv_parser.add_argument('-extractor', default='pre-trained-models/iv_plda/final_ie.txt')
    iv_parser.add_argument('-plda', default='pre-trained-models/iv_plda/plda.txt')
    iv_parser.add_argument('-mean', default='pre-trained-models/iv_plda/mean.vec')
    iv_parser.add_argument('-transform', default='pre-trained-models/iv_plda/transform.txt')
    iv_parser.add_argument('-model_file', default='model_file/iv_plda/speaker_model_iv_plda')
    iv_parser.add_argument('-gmm_frame_bs', type=int, default=200)
    
    xv_parser = subparser.add_parser("xv_plda")
    xv_parser.add_argument('-extractor', default='pre-trained-models/xv_plda/xvecTDNN_origin.ckpt')
    xv_parser.add_argument('-plda', default='pre-trained-models/xv_plda/plda.txt')
    xv_parser.add_argument('-mean', default='pre-trained-models/xv_plda/mean.vec')
    xv_parser.add_argument('-transform', default='pre-trained-models/xv_plda/transform.txt')
    xv_parser.add_argument('-model_file', default='model_file/xv_plda/speaker_model_xv_plda')
    
    audionet_c_parser = subparser.add_parser("audionet_csine")
    audionet_c_parser.add_argument('-extractor', 
                default='pre-trained-models/audionet/cnn-natural-model-noise-0-002-50-epoch.pt.tmp8540_ckpt')
    audionet_c_parser.add_argument('-label_encoder', default='./label-encoder-audionet-Spk251_test.txt')

    # true threshold and threshold estimation
    parser.add_argument('-threshold', type=float, default=None) # for SV/OSI task; real threshold of the model
    parser.add_argument('-threshold_estimated', type=float, default=None) # for SV/OSI task; estimated threshold by FAKEBOB
    parser.add_argument('-thresh_est_wav_path', type=str, nargs='+', default=None) # the audio path used to estimate the threshold, should from imposter (initially rejected)
    parser.add_argument('-thresh_est_step', type=float, default=0.1) # the smaller, the accurate, but the slower
    
    #### add a defense layer in the model
    #### Note that for white-box attack, the defense method needs to be differentiable
    parser.add_argument('-defense', nargs='+', default=None)
    parser.add_argument('-defense_param', nargs='+', default=None)
    parser.add_argument('-defense_flag', nargs='+', default=None, type=int)
    parser.add_argument('-defense_order', default='sequential', choices=['sequential', 'average'])

    parser.add_argument('-root', type=str, required=True)
    parser.add_argument('-name', type=str, required=True)
    parser.add_argument('-des', type=str, default=None) # path to store adver audios
    parser.add_argument('-task', type=str, default='CSI', choices=['CSI', 'SV', 'OSI']) # the attack use this to set the loss function
    parser.add_argument('-wav_length', type=int, default=None)

    ## common attack parameters
    parser.add_argument('-targeted', action='store_true', default=False)
    parser.add_argument('-target_label_file', default=None) # the path of the file containing the target label; generated by set_target_label.py
    parser.add_argument('-batch_size', type=int, default=1)
    parser.add_argument('-EOT_size', type=int, default=1)
    parser.add_argument('-EOT_batch_size', type=int, default=1)
    parser.add_argument('-start', type=int, default=0)
    parser.add_argument('-end', type=int, default=-1)

    for system_type_parser in [iv_parser, xv_parser, audionet_c_parser]:
        
        subparser = system_type_parser.add_subparsers(dest='attacker')

        fgsm_parser = subparser.add_parser("FGSM")
        fgsm_parser.add_argument("-epsilon", type=float, default=0.002)
        fgsm_parser.add_argument('-loss', type=str, choices=['Entropy', 'Margin'], default='Entropy')

        pgd_parser = subparser.add_parser("PGD")
        pgd_parser.add_argument('-step_size', type=float, default=0.0004)
        pgd_parser.add_argument('-epsilon', type=float, default=0.002)
        pgd_parser.add_argument('-max_iter', type=int, default=10) # PGD-10 default
        pgd_parser.add_argument('-num_random_init', type=int, default=0)
        pgd_parser.add_argument('-loss', type=str, choices=['Entropy', 'Margin'], default='Entropy')

        cwinf_parser = subparser.add_parser("CWinf")
        cwinf_parser.add_argument('-step_size', type=float, default=0.001)
        cwinf_parser.add_argument('-epsilon', type=float, default=0.002)
        cwinf_parser.add_argument('-max_iter', type=int, default=10) # PGD-10 default
        cwinf_parser.add_argument('-num_random_init', type=int, default=0)

        cw2_parser = subparser.add_parser("CW2")
        cw2_parser.add_argument('-initial_const', type=float, default=1e-3)
        cw2_parser.add_argument('-binary_search_steps', type=int, default=9)
        cw2_parser.add_argument('-max_iter', type=int, default=10000)
        cw2_parser.add_argument('-stop_early', action='store_false', default=True)
        cw2_parser.add_argument('-stop_early_iter', type=int, default=1000)
        cw2_parser.add_argument('-lr', type=float, default=1e-2)
        cw2_parser.add_argument('-confidence', type=float, default=0.)
        # cw2_parser.add_argument('-dist_loss', default='L2', choices=['L2', 'PMSQE', 'PESQ'])

        fakebob_parser = subparser.add_parser("FAKEBOB")
        fakebob_parser.add_argument('-confidence', type=float, default=0.)
        fakebob_parser.add_argument("--epsilon", "-epsilon", default=0.002, type=float)
        fakebob_parser.add_argument("--max_iter", "-max_iter", default=1000, type=int)
        fakebob_parser.add_argument("--max_lr", "-max_lr", default=0.001, type=float)
        fakebob_parser.add_argument("--min_lr", "-min_lr", default=1e-6, type=float)
        fakebob_parser.add_argument("--samples_per_draw", "-samples", default=50, type=int)
        fakebob_parser.add_argument("--samples_batch", "-samples_batch", default=50, type=int)
        fakebob_parser.add_argument("--sigma", "-sigma", default=0.001, type=float)
        fakebob_parser.add_argument("--momentum", "-momentum", default=0.9, type=float)
        fakebob_parser.add_argument("--plateau_length", "-plateau_length", default=5, type=int)
        fakebob_parser.add_argument("--plateau_drop", "-plateau_drop", default=2.0, type=float)
        fakebob_parser.add_argument("--stop_early", "-stop_early", action='store_false', default=True)
        fakebob_parser.add_argument("--stop_early_iter", "-stop_early_iter", type=int, default=100)

        siren_parser = subparser.add_parser("SirenAttack")
        siren_parser.add_argument('-confidence', type=float, default=0.)
        siren_parser.add_argument("-epsilon", default=0.002, type=float)
        siren_parser.add_argument("-max_epoch", default=30, type=int)
        siren_parser.add_argument("-max_iter", default=300, type=int)
        siren_parser.add_argument("-c1", type=float, default=1.4961)
        siren_parser.add_argument("-c2", type=float, default=1.4961)
        siren_parser.add_argument("-n_particles", default=50, type=int)
        siren_parser.add_argument("-w_init", type=float, default=0.9)
        siren_parser.add_argument("-w_end", type=float, default=0.1)

        kenan_parser = subparser.add_parser("kenan")
        kenan_parser.add_argument("-atk_name", default='fft', type=str, choices=['fft', 'ssa'])
        kenan_parser.add_argument("-raster_width", default=100, type=int)
        kenan_parser.add_argument("-max_iter", default=15, type=int)
        kenan_parser.add_argument("-early_stop", type=int, default=0)

    args = parser.parse_args()
    return args

def save_audio(advers, names, root, fs=16000):
    for adver, name in zip(advers[:, 0, :], names):
        if 0.9 * adver.max() <= 1 and 0.9 * adver.min() >= -1:
            adver = adver * (2 ** (bits-1))
        if type(adver) == torch.Tensor:
            adver = adver.detach().cpu().numpy()
        adver = adver.astype(np.int16)
        spk_id = name.split("-")[0]
        spk_dir = os.path.join(root, spk_id)
        if not os.path.exists(spk_dir):
            os.makedirs(spk_dir)
        adver_path = os.path.join(spk_dir, name + ".wav")
        write(adver_path, fs, adver)





def main(args):
    model = EncoderDecoderASR.from_hparams(source='speechbrain/asr-crdnn-rnnlm-librispeech', 
        savedir='data/pretrained_models/') 
    attacker = FGSM(model, task=args.task, epsilon=args.epsilon, loss=args.loss, targeted=args.targeted, 
                        batch_size=args.batch_size, EOT_size=args.EOT_size, EOT_batch_size=args.EOT_batch_size, verbose=1)
    
if __name__ == "__main__":
    main(parse_args())